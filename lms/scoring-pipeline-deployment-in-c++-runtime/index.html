
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Scoring Pipeline Deployment in C&#43;&#43; Runtime</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <link rel="stylesheet" href="custom.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="scoring-pipeline-deployment-in-c&#43;&#43;-runtime"
                  title="Scoring Pipeline Deployment in C&#43;&#43; Runtime"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="Objective" duration="0">
        <p><strong>Machine Learning Model Deployment</strong> is the process of making your model available in production environments, so they can be used to make predictions for other software systems [1]. Before model deployment, <strong>feature engineering</strong> occurs in the form of preparing data that later on will be used to train a model [2]. Driverless AI <strong>Automatic Machine Learning (AutoML)</strong> combines the best feature engineering and one or more <strong>machine learning models</strong> into a scoring pipeline [3][4]. The <strong>scoring pipeline</strong> is used to score or predict data when given new test data [5]. The scoring pipeline comes in two flavors. The first scoring pipeline is a <strong>Model Object, Optimized(MOJO) Scoring Pipeline</strong>, which is a standalone, low-latency model object designed to be easily embeddable in production environments. The second scoring pipeline is a Python Scoring Pipeline, which has a heavy footprint that is all Python and uses the latest libraries of Driverless AI to allow for executing custom scoring recipes[6].</p>
<p>By the end of this tutorial, you will predict the <strong>cooling condition</strong> for a <strong>Hydraulic System Test Rig</strong> by deploying an <strong>embeddable MOJO Scoring Pipeline</strong> into C++ Runtime using <strong>Python</strong> and <strong>R</strong>. The Hydraulic System Test Rig data comes from the <a href="https://archive.ics.uci.edu/ml/datasets/Condition+monitoring+of+hydraulic+systems#" target="_blank">UCI Machine Learning Repository: Condition Monitoring of Hydraulic Systems Data Set</a>. Hydraulic System Test Rigs are used to test components in Aircraft Equipment, Ministry of Defense, Automotive Applications, and more [7]. This Hydraulic Test Rig is capable of testing a range of flow rates that can achieve different pressures with the ability to heat and cool to simulate testing under different conditions [8]. Testing the pressure, volume flow and temperature is possible by Hydraulic Test Rig sensors and digital displays. The display panel alerts the user when certain testing criteria is met displaying either a green/red light [8]. A filter blockage panel indicator is integrated into the panel to ensure the Hydraulic Test Rig&#39;s oil is maintained [8]. The cooling filtration solution is designed to minimize power consumption and expand the life of the Hydraulic Test Rig. We are predicting cooling conditions for Hydraulic System Predictive Maintenance. When the cooling condition is low, our prediction tells us that the cooling of the Hydraulic System is close to total failure and we may need to look into replacing the cooling filtration solution soon.</p>
<p class="image-container"><img alt="cylinder-diagram-1" src="img/a8b156e42a5fb1f0.jpg"></p>
<p>Figure: Hydraulic Test Rig General Cylinder Diagram</p>
<p>The Hydraulic Test Rig consists of a primary and secondary cooling filtration circuit with pumps that deliver flow and pressure to the oil tank. The oil tank box at the bottom. There is a pressure relief control valve for controlling the rising and falling flows. There is a pressure gauge for measuring the pressure.</p>
<h2 is-upgraded>Resources</h2>
<p>[1] H2O.ai Community AI Glossary: <a href="https://www.h2o.ai/community/glossary/machine-learning-model-deployment-productionization-productionizing-machine-learning-models" target="_blank">Machine Learning Model Deployment</a></p>
<p>[2] H2O.ai Community AI Glossary: <a href="https://www.h2o.ai/community/glossary/feature-engineering-data-transformation" target="_blank">Feature Engineering</a></p>
<p>[3] H2O.ai Community AI Glossary: <a href="https://www.h2o.ai/community/glossary/automatic-machine-learning-automl" target="_blank">Automatic Machine Learning (AutoML)</a></p>
<p>[4] H2O.ai Community AI Glossary: <a href="https://www.h2o.ai/community/glossary/machine-learning-model" target="_blank">Machine Learning Model</a></p>
<p>[5] H2O.ai Community AI Glossary: <a href="https://www.h2o.ai/community/glossary/scoring-pipeline" target="_blank">Scoring Pipeline</a></p>
<p>[6] H2O.ai Community AI Glossary: <a href="https://www.h2o.ai/community/glossary/model-object-optimized-mojo" target="_blank">Model Object, Optimized (MOJO) Scoring Pipeline</a></p>
<p>[7] <a href="https://www.savery.co.uk/systems/test-benches" target="_blank">SAVERY - HYDRAULIC TEST RIGS AND BENCHES</a></p>
<p>[8] <a href="https://www.hydrotechnik.co.uk/flow-and-temperature-hydraulic-test-bed" target="_blank">HYDROTECHNIK - Flow and Temperature Testing Components</a></p>


      </google-codelab-step>
    
      <google-codelab-step label="Prerequisites" duration="0">
        <ul>
<li>Skilled in Python and/or R Programming</li>
<li>Driverless AI Environment</li>
<li>Driverless AI License  <ul>
<li>The license is needed for using the <strong>MOJO2 C++ Runtime Python Wrapper API</strong> and <strong>R Wrapper API</strong> to execute the <strong>MOJO Scoring Pipeline</strong> for making predictions</li>
<li><a href="https://www.h2o.ai/try-driverless-ai/" target="_blank">21 day trial license</a></li>
<li>If you need to purchase a Driverless AI license, reach out to our sales team via the <a href="https://www.h2o.ai/company/contact/" target="_blank"><strong>contact us form</strong></a>.</li>
</ul>
</li>
<li>Linux OS (x86 or IBM Power PC) or Mac OS X (10.9 or newer)</li>
<li>Anaconda or Miniconda</li>
<li>Basic knowledge of Driverless AI or completion of the following tutorials:  <ul>
<li><a href="https://training.h2o.ai/products/tutorial-1a-automatic-machine-learning-introduction-with-driverless-ai" target="_blank">Tutorial 1A: Automatic Machine Learning Introduction with Driverless AI Test Drive</a></li>
<li><a href="https://training.h2o.ai/products/tutorial-4a-scoring-pipeline-deployment-introduction#tab-product_tab_overview" target="_blank">Tutorial 4A: Scoring Pipeline Deployment Introduction</a></li>
<li><a href="https://training.h2o.ai/products/tutorial-4b-scoring-pipeline-deployment-templates" target="_blank">Tutorial 4B: Scoring Pipeline Deployment Templates</a></li>
</ul>
</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Task 1: Set Up Environment" duration="0">
        <h2 is-upgraded>Create Environment Directory Structure</h2>
<pre><code language="language-bash" class="language-bash"># Create directory structure for DAI MOJO C++ Projects

# Create directory where the mojo-pipeline/ folder will be stored
mkdir $HOME/dai-mojo-cpp/

</code></pre>
<h2 is-upgraded>Set Up Driverless AI MOJO Requirements</h2>
<h3 is-upgraded>Download MOJO Scoring Pipeline</h3>
<p>1. If you have not downloaded the MOJO Scoring Pipeline, go to <a href="https://training.h2o.ai/products/tutorial-4b-scoring-pipeline-deployment-templates" target="_blank">Tutorial 4B: Scoring Pipeline Deployment Templates</a> , then go to Task 1: Set Up Environment, then <strong>Download MOJO Scoring Pipeline</strong> to download it. When finished, come back to this tutorial.</p>
<p>2. Move the <strong>mojo.zip</strong> file to <strong>dai-mojo-cpp</strong>/ folder and then extract it:</p>
<pre><code language="language-bash" class="language-bash">cd $HOME/dai-mojo-cpp/
mv $HOME/Downloads/mojo.zip .
unzip mojo.zip
</code></pre>
<h3 is-upgraded>Download MOJO2 Python and R Runtime</h3>
<p>We can download the <strong>MOJO2 C++ Runtime Python Wrapper API and R Wrapper API</strong> in Driverless AI. There are 2 places where we can download the MOJO2 Python and R runtime.</p>
<p>1. The first place is by clicking on <strong>Download MOJO Scoring Pipeline</strong>, then click Python and click <strong>Download the MOJO2 Py Runtime</strong> hyperlink.</p>
<p class="image-container"><img alt="download-mojo2-py-runtime-1" src="img/40d48bf16b367c2d.jpg"></p>
<p>2. Similar for the MOJO2 R runtime, click R, then <strong>Download the MOJO2 R Runtime</strong> hyperlink.</p>
<p class="image-container"><img alt="download-mojo2-r-runtime-2" src="img/26c4e5a7b967c122.jpg"></p>
<p>3. The second place you can find these runtimes is under the <strong>Resources</strong> drop-down list.</p>
<p class="image-container"><img alt="download-mojo2-py-r-runtime-3" src="img/c839efb0962085ef.jpg"></p>
<p>4. Click <strong>MOJO2 Py Runtime</strong> and/or <strong>MOJO2 R Runtime</strong> to download the runtime.</p>
<p>5. Download and install Anaconda:</p>
<pre><code language="language-bash" class="language-bash"># Download Anaconda
wget https://repo.anaconda.com/archive/Anaconda3-2020.02-Linux-x86_64.sh

# Install Anaconda
bash Anaconda3-2020.02-Linux-x86_64.sh
</code></pre>
<p>6. Move the <strong>MOJO2 Py Runtime</strong> file to $HOME folder:</p>
<pre><code language="language-bash" class="language-bash">cd $HOME

# If you have Mac, Move the MOJO2 Py runtime for Mac OS X to $HOME folder
mv $HOME/Downloads/daimojo-2.2.0-cp36-cp36m-macosx_10_7_x86_64.whl .
 
# If you have Linux, Move the MOJO2 Py runtime for Linux x86 to $HOME folder
mv $HOME/Downloads/daimojo-2.2.0-cp36-cp36m-linux_x86_64.whl .
 
# If you have Linux PPC, Move the MOJO2 Py runtime for Linux PPC to $HOME folder
mv $HOME/Downloads/daimojo-2.2.0-cp36-cp36m-linux_ppc64le.whl .
</code></pre>
<p>7. Move the <strong>MOJO2 R Runtime</strong> file to $HOME folder:</p>
<pre><code language="language-bash" class="language-bash">cd $HOME
# If you have Mac, Move the MOJO2 R runtime for Mac OS X to $HOME folder
mv $HOME/Downloads/daimojo_2.2.0_x86_64-darwin.tar.gz .
 
# If you have Linux, Move the MOJO2 R runtime for Linux x86 to $HOME folder
mv $HOME/Downloads/daimojo_2.2.0_x86_64-linux.tar.gz .
 
# If you have Linux PPC, Move the MOJO2 R runtime for Linux PPC to $HOME folder
mv $HOME/Downloads/daimojo_2.2.0_ppc64le-linux.tar.gz .
</code></pre>
<h2 is-upgraded>Install MOJO2 Python and R Runtime Dependencies</h2>
<p>8. Create virtual environment and install Python and R packages in it</p>
<pre><code language="language-bash" class="language-bash"># Install Python 3.6.10
conda create -y -n model-deployment python=3.6
conda activate model-deployment
</code></pre>
<p>9. Install Python Packages</p>
<pre><code language="language-bash" class="language-bash"># Install Python Packages
# Install datable 0.10.1
pip install datatable
# Install pandas
pip install pandas
# Install scipy
pip install scipy
</code></pre>
<p>10. Depending on your OS, run one of the following commands to install <strong>MOJO2 Py Runtime</strong>:</p>
<pre><code language="language-bash" class="language-bash"># Install the MOJO2 Py runtime on Mac OS X
pip install $HOME/daimojo-2.2.0-cp36-cp36m-macosx_10_7_x86_64.whl
 
# Install the MOJO2 Py runtime on Linux x86
pip install $HOME/daimojo-2.2.0-cp36-cp36m-linux_x86_64.whl
 
# Install the MOJO2 Py runtime on Linux PPC
pip install $HOME/daimojo-2.2.0-cp36-cp36m-linux_ppc64le.whl
</code></pre>
<p>11. Install R packages</p>
<pre><code language="language-bash" class="language-bash"># Install R Packages
# Install R r-essentials 3.6.0
conda install -y -c r r-essentials

# Install R r-rcpp 1.0.3
conda install -y -c conda-forge r-rcpp=1.0.3

# Install R data.table
conda install -y -c r r-data.table
</code></pre>
<h2 is-upgraded>Set Driverless AI License Key</h2>
<p>12. Set the Driverless AI License Key as a temporary environment variable</p>
<pre><code language="language-bash" class="language-bash"># Set Driverless AI License Key
export DRIVERLESS_AI_LICENSE_KEY=&#34;{license-key}&#34;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Task 2: Deploy Scoring Pipeline in C&#43;&#43; Runtime Concepts" duration="0">
        <h2 is-upgraded>MOJO Scoring Pipeline Files</h2>
<p>After downloading the MOJO scoring pipeline, the <strong>mojo-pipeline</strong> folder comes with many files needed to execute the MOJO scoring pipeline, which include <strong>pipeline.mojo</strong> and <strong>example.csv</strong>. However, the <strong>mojo-pipeline</strong> folder does not come with the MOJO2 Py Runtime or MOJO2 R Runtime. These two MOJO2 APIs can be downloaded as separate assets from Driverless AI. The <strong>pipeline.mojo</strong> is the standalone scoring pipeline in MOJO format. This pipeline file contains the packaged feature engineering pipeline and the machine learning model. The <strong>daimojo-2.2.0-cp36-cp36m-{OS: mac, linux. IBM Power}.whl</strong> is the MOJO2 Python API. The <strong>daimojo</strong><strong><em>2.2.0</em></strong><strong>{OS: mac, linux, IBM Power}.tar.gz</strong> is the MOJO2 R API. The <strong>example.csv</strong> contains sample test data.</p>
<h2 is-upgraded>Embed the MOJO in the C++ Runtime via Python or R Wrappers</h2>
<p>If you have gone through the earlier scoring pipeline deployment tutorials, you have seen how we deploy the MOJO Scoring Pipeline to a server or serverless instance. Some clients interact with the server to trigger it to execute the MOJO to make predictions. An alternative way to deploy the MOJO Scoring Pipeline is to embed it directly into the C++ Runtime, where your application is running. The MOJO C++ Runtime comes with Python and R wrappers called MOJO2 Py Runtime and MOJO2 R Runtime. So if you are building a Python or R application using an Integrated Development Environment (IDE) or a text editor, you can import the MOJO2 Python API or MOJO2 R API. Then use it to load the MOJO, put your test data into a MOJO frame, then perform predictions on the data and return the results.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Task 3: Batch Scoring via Scoring Pipeline Execution" duration="0">
        <p>We will be executing the MOJO scoring pipeline using the Python and R wrapper. We will be doing batch scoring on the Hydraulic System example csv data to classify for the Hydraulic System cooling condition.</p>
<h2 is-upgraded>Batch Scoring via Run R Wrapper Program</h2>
<p>1. Start R to enter R interactive terminal:</p>
<pre><code language="language-bash" class="language-bash">R
</code></pre>
<p class="image-container"><img alt="batch-scoring-via-run-r-program-1" src="img/5c8b1bb77637f6fe.jpg"></p>
<p>2. Now that we are in the R interactive terminal, we will install the MOJO2 R Runtime:</p>
<pre><code language="language-bash" class="language-bash"># Install the R MOJO runtime using one of the methods below

homePath &lt;- Sys.getenv(&#34;HOME&#34;)

# Install the R MOJO runtime on PPC Linux
install.packages(homePath + &#34;/daimojo_2.2.0_ppc64le-linux.tar.gz&#34;)

# Install the R MOJO runtime on x86 Linux
install.packages(homePath + &#34;/daimojo_2.2.0_x86_64-linux.tar.gz&#34;)

#Install the R MOJO runtime on Mac OS X
install.packages(homePath + &#34;/daimojo_2.2.0_x86_64-darwin.tar.gz&#34;)
</code></pre>
<p>3. Next we will load the Driverless AI MOJO library and load the MOJO scoring pipeline:</p>
<pre><code language="language-bash" class="language-bash"># Load the MOJO
library(daimojo)
m &lt;- load.mojo(homePath + &#34;/dai-mojo-cpp/mojo-pipeline/pipeline.mojo&#34;)
</code></pre>
<p>4. We will then retrieve the creation time of the MOJO and the UUID of the experiment:</p>
<pre><code language="language-bash" class="language-bash"># retrieve the creation time of the MOJO
create.time(m)

# retrieve the UUID of the experiment
uuid(m)
</code></pre>
<p>5. We will then set feature data types and names in the column class header, which will be used to initialize the R datatable header and data types, and load Hydraulic System example csv data into the table:</p>
<pre><code language="language-bash" class="language-bash"># Load data and make predictions
col_class &lt;- setNames(feature.types(m), feature.names(m))  # column names and types

library(data.table)
d &lt;- fread(homePath + &#34;/dai-mojo-cpp/mojo-pipeline/example.csv&#34;, colClasses=col_class, header=TRUE, sep=&#34;,&#34;)
</code></pre>
<p>6. Lastly, we will use our MOJO scoring pipeline to predict the Hydraulic System&#39;s cooling condition for each row within the table:</p>
<pre><code language="language-bash" class="language-bash">predict(m, d)
</code></pre>
<p class="image-container"><img alt="batch-scoring-via-run-r-program-2" src="img/f4a682cd6776f54e.jpg"></p>
<p>This classification output is the batch scoring done for our Hydraulic System cooling condition. You should receive classification probabilities for cool_cond_y.3, cool_cond_y.20, and cool_cond_y.100. The 3 means the Hydraulic cooler is close to operating at total failure, 20 means it is operating at reduced efficiency and 100 means it is operating at full efficiency.</p>
<p>7. We will quit the R interactive terminal:</p>
<pre><code language="language-bash" class="language-bash">quit()
</code></pre>
<p>R will ask you if you want to save the workspace image, feel free to save it if you want.</p>
<p>So that is how you execute the MOJO scoring pipeline to do batch scoring for the Hydraulic System cooling condition using the R wrapper in the C++ Runtime.</p>
<h2 is-upgraded>Batch Scoring via Run Python Wrapper Program</h2>
<p>1. Start python to enter Python interactive terminal:</p>
<p class="image-container"><img alt="batch-scoring-via-run-py-program-1" src="img/8850fab9e84d0727.jpg"></p>
<p>2. Let&#39;s import the Driverless AI MOJO model package and load the MOJO scoring pipeline:</p>
<pre><code language="language-bash" class="language-bash"># import the daimojo model package
import os.path
import daimojo.model

homePath = os.path.expanduser(&#34;~&#34;)
# specify the location of the MOJO
m = daimojo.model(homePath + &#34;/dai-mojo-cpp/mojo-pipeline/pipeline.mojo&#34;)
</code></pre>
<p>3. We will then retrieve the creation time of the MOJO and the UUID of the experiment:</p>
<pre><code language="language-bash" class="language-bash"># retrieve the creation time of the MOJO
m.created_time

# retrieve the UUID of the experiment
m.uuid
</code></pre>
<p>4. We can also retrieve a list of missing values, feature names, feature types, output names, and output types:</p>
<pre><code language="language-bash" class="language-bash"># retrieve a list of missing values
m.missing_values
# retrieve the feature names
m.feature_names
# retrieve the feature types
m.feature_types

# retrieve the output names
m.output_names
# retrieve the output types
m.output_types
</code></pre>
<p>5. Now we will import the Python datatable package, load the Hydraulic System example csv data into the datatable, set the table to ignore strings that equal the missing values and display the table:</p>
<pre><code language="language-bash" class="language-bash"># import the datatable module
import datatable as dt

# parse the example.csv file
pydt = dt.fread(homePath + &#34;/dai-mojo-cpp/mojo-pipeline/example.csv&#34;, na_strings=m.missing_values, header=True, separator=&#39;,&#39;)

pydt
</code></pre>
<p>6. We can also display the table column types:</p>
<pre><code language="language-bash" class="language-bash"># retrieve the column types
pydt.stypes
</code></pre>
<p>7. We will use our MOJO scoring pipeline to predict the Hydraulic System&#39;s cooling condition for each row within the table:</p>
<pre><code language="language-bash" class="language-bash"># make predictions on the example.csv file
res = m.predict(pydt)

# retrieve the predictions
res
</code></pre>
<p class="image-container"><img alt="batch-scoring-via-run-py-program-2" src="img/7842142990d3c365.jpg"></p>
<p>This classification output is the batch scoring done for our Hydraulic System cooling condition. You should receive classification probabilities for cool_cond_y.3, cool_cond_y.20, and cool_cond_y.100. The 3 means the Hydraulic cooler is close to operating at total failure, 20 means it is operating at reduced efficiency and 100 means it is operating at full efficiency.</p>
<p>8. There is some more data we can retrieve from our res predictions, which include the prediction column names and column types:</p>
<pre><code language="language-bash" class="language-bash"># retrieve the prediction column names
res.names

# retrieve the prediction column types
res.stypes
</code></pre>
<p>9. We can also convert the datatable results to other data structures, such as pandas, numpy and list:</p>
<pre><code language="language-bash" class="language-bash"># need pandas
res.to_pandas()

# need numpy  
res.to_numpy()

res.to_list()
</code></pre>
<p>You just learned how to execute the MOJO scoring pipeline to do batch scoring for the Hydraulic System cooling condition using the Python wrapper in the C++ Runtime.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Task 4: Challenge" duration="0">
        <h2 is-upgraded>Execute Scoring Pipeline for a New Dataset</h2>
<p>There are various challenges one could do, you could do something that helps you in your daily life or job. Maybe there is a dataset you are working with, you could reproduce the steps we did above, but for your dataset, build a new experiment and execute your MOJO scoring pipeline to do batch scoring or interactive scoring.</p>
<h2 is-upgraded>Embed Scoring Pipeline into Existing Program</h2>
<p>Another challenge could be to use the existing MOJO scoring pipeline we executed and instead of using the examples we shared above, integrate the scoring pipeline into an existing Python or R program.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Next Steps" duration="0">
        <ul>
<li><a href="https://training.h2o.ai/products/tutorial-4c-scoring-pipeline-execution-in-java-runtime" target="_blank">Tutorial 4C: Scoring Pipeline Deployment in Java Runtime</a></li>
<li><a href="https://training.h2o.ai/products/tutorial-4e-scoring-pipeline-deployment-in-python-runtime" target="_blank">Tutorial 4E: Scoring Pipeline Deployment in Python Runtime</a></li>
<li><a href="https://training.h2o.ai/products/tutorial-4f-scoring-pipeline-deployment-to-apache-nifi" target="_blank">Tutorial 4F: Scoring Pipeline Deployment to Apache NIFI</a></li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Appendix A: Glossary" duration="0">
        <p>Refer to <a href="https://www.h2o.ai/community/top-links/ai-glossary-search?p=3" target="_blank">H2O.ai Glossary</a> for relevant Model Deployment Terms</p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
